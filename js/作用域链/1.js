function test() {

}

// 函数也是对象，是对象就可以有属性
// test.name      test.prototype
// test.[[scope]]  // 函数的作用域属性，但是不能拿出来用，这是隐式属性，就像XX表面上看起来有一个女朋友，实际上有3个，但是你问他他就会告诉你只有一个，打死不会说有3个

// test() ---> AO:{} // 回收
// test() ---> AO:{}


function a() {
  function b() {
    var b = 222
  }
  var a = 111
  b()
  console.log(a)
}
var glob = 100
a()

// a 定义  a.[[scope]] ---> 0 : GO{}
// a 执行 a.[[scope]] ---> 0: AO{}  1: GO{}

// 看图三
//  a函数的执行前一刻作用域链中多出来了一个AO对象，出现在作用链的最顶端


// b 函数出生在a函数里面，执行时（前一刻）会创建出来一个b自己的AO对象，然后插入到作用域链的顶端
// 看图4



// 每一个函数都有自己的作用域链，从自己的作用域链当中找你要的值

// b执行完了，b的AO就要销毁了

// 紧接着a也说，那我也执行完了，我的AO也要销毁了，因为a的AO中有b函数，所以a的AO被销毁b函数会直接失效，
// 等待下一次如果又有a函数的调用 a()，才会又重新创建一个 a 的AO，a的执行带来了b的声明，b要是再被调用的话又会创建一个b的AO出现在作用域链的顶端，周而复始




// 牛刀小试
function a() {

  function b() {

    function c() {

    }
    c()
  }
  b()
}
a()

// 1. a 定义  a.[[scope]] --> 0: GO{}
// 2. a 执行  a.[[scope]] --> 0: aAO{}   1: GO{}

// a的执行产生了一个b的定义
// 3. b 定义 b.[[scope]] --> 0: aAO{}   1: GO{}
// 4. b 执行 b.[[scope]] --> 0: bAO{}   1: aAO{}   2: GO{}

// b的执行产生了c的定义
// 5. c 定义 c.[[scope]] --> 0: bAO{}   1: aAO{}   2: GO{}
// 6. c 执行 c.[[scope]] --> 0: cAO{}   1: bAO{}   2: aAO{}   3: GO{}